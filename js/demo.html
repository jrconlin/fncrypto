<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>fnCrypto demo</title>
    <!-- link href="style.css" rel="stylesheet" type="text/css" / -->

</head>
<body>
    <h1>fnCrypto demo</h1>
    <div id="result"></div>
    <script src="../sjcl/core.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script language="javascript">

    function FNCrypto() {
        var self = this;

        self._bitSize = 256;
        self._myAppName = 'fnCryptoClient';

        /** generate a sting of random characters 

        @param bitLen bit length of string to generate (defaults to self._bitSize)
        */
        self._randString = function(bitLen) {
            var val=""
            if (bitLen == undefined) {
                bitLen = self._bitSize;
            }
            //var chars = sjcl.codec.base64._chars;
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var charsLen = chars.length;
            for (var i=0; i < bitLen/8; i++) {
                val += chars[Math.floor(Math.random() * charsLen)];
            }
            return val;
        }

        self._newSiteKey = function() {
            var bits = 0;
            return Math.round(Math.random() * Math.pow(2, 256));
        }

        self._getStorage = function(key) {
            if (key == undefined) {
                key = 'crypto';
            }
            var storeInfo = sessionStorage.getItem(key);
            if (storeInfo != undefined) {
                storeInfo = JSON.parse(storeInfo);
            }
            return storeInfo;
        }

        self._setStorage = function(key, info) {
            sessionStorage.setItem(key, JSON.stringify(info));
        }

        // -- Public functions

        /** retrieve/generate the "key bundle" for this site.

        Key Bundle consists of an object containing:
        "site" protocol:sitename of the originating site.
        "encryptionKey": Encryption/Decryption key.
        'hmac": HMAC value for signing the cipherText

        Content is currently stored in localStorage. Key Bundle is private and
        MUST NOT be shared.
        */
        self.getKeyBundle = function(site) {
            var keyBundle;
            keyBundle = self._getStorage(site + '-kb')
            if (keyBundle != undefined) {
                return keyBundle
            }
            var info = self._myAppName + "-AES_256_CBC-HMAC256" + site;
            var siteKey = self._newSiteKey();
            var encryptionKey = sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(siteKey + info + "\x01"));
            var keyBundle = {'site': site,
                'encryptionKey': encryptionKey,
                'hmac': sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(encryptionKey + info + "\x02"))};
            self._setStorage(site + '-kb', keyBundle);
            return keyBundle;
        }

        self.encrypt = function(plainText, site, keyBundle, iv) {
            if (plainText == undefined) {
                throw Exception('nothing to encrypt');
            }
            if (site == undefined) {
                site = self.getSite();
            }
            if (keyBundle == undefined) {
                keyBundle = self.getKeyBundle(site);
            }
            //
            if (iv == undefined) {
                iv = sjcl.codec.base64.toBits(self._randString());
            }
            var key = sjcl.hash.sha256.hash(sjcl.codec.hex.fromBits(sjcl.codec.hex.toBits(keyBundle.encryptionKey).concat(iv)));
            var aes = new sjcl.cipher.aes(key);
            var cipherText = sjcl.codec.base64.fromBits(aes.encrypt(sjcl.codec.utf8String.toBits(plainText)));
            var hmac = sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(keyBundle.hmac + cipherText));
            return {'iv': sjcl.codec.base64.fromBits(iv),
                'cipherText': cipherText,
                'hmac': hmac}
        }

        /** Decrypt content returned from an "encrypt" call.

        @param site    protocol + host name for origin site.
        @param cryptBlock the encrypted info
        @param keyBundle optional keyBundle to use instead of the one stored for site

        The cryptBlock is an object that contains the following:
        { 'iv': base64 encoded Init Vector for this block.
            'cipherText': base64 encoded, AES encrypted text
            'hmac': HMAC for the cypherText derived from the keyBundle HMAC
        }

        @return an object containing:
        {
            'plainText': The UTF8 encoded string containing the decrypted content.
        }

        Notes:
            decrypted content may be left padded with \x0 characters.
            
        */
        self.decrypt = function(cryptBlock, site, keyBundle) {
            if (cryptBlock == undefined) {
                return;
            }
            if (site == undefined) {
                site = self.getSite();
            }
            if (keyBundle == undefined) {
                keyBundle = self.getKeyBundle(site);
            }
            // check the hmac
            var localmac = sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(keyBundle.hmac + cryptBlock.cipherText));
            if (localmac != cryptBlock.hmac) {
                throw Exception('bad mac');
            }
            var iv = sjcl.codec.base64.toBits(cryptBlock.iv);
            var key = sjcl.hash.sha256.hash(sjcl.codec.hex.fromBits(sjcl.codec.hex.toBits(keyBundle.encryptionKey).concat(iv)));
            var aes = new sjcl.cipher.aes(key);
            // Nulls can appear at the end of strings as padding. Strip those
            var plainText = sjcl.codec.utf8String.fromBits(aes.decrypt(sjcl.codec.base64.toBits(cryptBlock.cipherText))).  replace(/\x00*$/, '');
            return {'plainText': plainText}
        }

        // TODO: 
        //   build register call
        //   push pull test message.

        self.getSite = function(){
            return document.location.protocol + document.location.host;
        }

        function isRegistered(site) {
            return self._getStorage(site + '-kb') !=  undefined;
        }

    }
        
    $(document).ready(function() {
        var crypt = new FNCrypto();
        var plainText = 'This is a test.';

        // Test: crypt and decrypt a block.
        var cryptoBlock = crypt.encrypt(plainText);
        console.debug(cryptoBlock);
        var response = crypt.decrypt(cryptoBlock);
        console.debug(response);
        console.debug(response.plainText == plainText);
        document.getElementById('result').innerHTML = response.plainText;
        // register the user with the site.
        // Generate an encryption key and hmac
        // generate a userID
        // request a crypted message from the server
                // send an encrypted request.
                // display the encrypted response.

        });

    </script>
</body>
</html>
